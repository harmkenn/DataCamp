---
title: "Working With Geospacial Data"
author: "Ken Harmon"
date: "`r format(Sys.time(), '%Y %B %d')`"
output:
  html_document:  
    keep_md: true
    code_folding: hide
    fig_height: 6
    fig_width: 12
    fig_align: 'center'
editor_options: 
  chunk_output_type: console
---

# {.tabset .tabset-fade}

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r load_libraries, include=FALSE}
# Use this R-Chunk to load all your libraries!
pacman::p_load(tidyverse, ggmap, sp, tmap, raster, rasterVis)
theme_set(theme_bw())
register_google(key = "AIzaSyAfnLNZjvYdMx-cyga_qA1oJ6P36dRGalA") 

```

https://campus.datacamp.com/courses/working-with-geospatial-data-in-r
https://github.com/cwickham/geospatial

## Google Mapping API

https://cloud.google.com/maps-platform/

```{r swd, eval=FALSE, echo=FALSE}
# this is set to not run during the knit process
# this sets the working directory to the file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

## Basic Mapping

Grabbing a background map
There are two steps to adding a map to a ggplot2 plot with ggmap:

Download a map using get_map()
Display the map using ggmap()
As an example, let's grab a map for New York City:

library(ggmap)

nyc <- c(lon = -74.0059, lat = 40.7128)
nyc_map <- get_map(location = nyc, zoom = 10)
get_map() has a number of arguments that control what kind of map to get, but for now you'll mostly stick with the defaults. The most important argument is the first, location, where you can provide a longitude and latitude pair of coordinates where you want the map centered. (We found these for NYC from a quick google search of "coordinates nyc".) The next argument, zoom, takes an integer between 3 and 21 and controls how far the mapped is zoomed in. In this exercise, you'll set a third argument, scale, equal to 1. This controls the resolution of the downloaded maps and you'll set it lower (the default is 2) to reduce how long it takes for the downloads.

Displaying the map is then as simple as calling ggmap() with your downloaded map as the only argument: ggmap(nyc_map)

Your turn! We are going to be looking at house sales in Corvallis, but you probably have no idea where that is! Let's find out.

Instructions
100 XP
We've created for you a pair of coordinates called corvallis. Get a map centered on Corvallis at the following zoom levels and use ggmap() to plot each. Don't forget to set scale = 1 to reduce download times.

zoom = 5 (Corvallis is in the State of Oregon on the West Coast of the USA.)
zoom = 13 (The Willamette River runs through town, and Corvallis is the home of Oregon State University.)

```{r gbm}

corvallis <- c(lon = -123.2620, lat = 44.5646)

# Get map at zoom level 5: map_5
map_5 <- get_map(corvallis, zoom = 5, scale = 1)

# Plot map at zoom level 5
ggmap(map_5)

# Get map at zoom level 13: corvallis_map
corvallis_map <- get_map(corvallis, zoom = 13, scale = 1)

# Plot map at zoom level 13
ggmap(corvallis_map)
```

Putting it all together
You now have a nice map of Corvallis, but how do you put the locations of the house sales on top?

Similar to ggplot(), you can add layers of data to a ggmap() call (e.g. + geom_point()). It's important to note, however, that ggmap() sets the map as the default dataset and also sets the default aesthetic mappings.

This means that if you want to add a layer from something other than the map (e.g. sales), you need to explicitly specify both the mapping and data arguments to the geom.

What does this look like? You've seen how you might make a basic plot of the sales:

ggplot(sales, aes(lon, lat)) + 
  geom_point()
An equivalent way to specify the same plot is:

ggplot() + 
  geom_point(aes(lon, lat), data = sales)
Here, we've specified the data and mapping in the call to geom_point() rather than ggplot(). The benefit of specifying the plot this way is you can swap out ggplot() for a call to ggmap() and get a map in the background of the plot.

Instructions
100 XP
The ggmap package has been loaded for you and corvallis_map from the previous exercise is available in your workspace.

First, take a look at the head() of the sales data. Can you see the columns specifying the location of the house?
Swap out the call to ggplot() with a call to ggmap() with corvallis_map.

```{r piat}
sales <- read.csv("sales.csv") %>% as_tibble()

# Look at head() of sales
head(sales)

# Swap out call to ggplot() with call to ggmap()
ggmap(corvallis_map) +
  geom_point(aes(lon, lat), data = sales)
```

Insight through aesthetics
Adding a map to your plot of sales explains some of the structure in the data: there are no house sales East of the Willamette River or on the Oregon State University campus. This structure is really just a consequence of where houses are in Corvallis; you can't have a house sale where there are no houses!

The value of displaying data spatially really comes when you add other variables to the display through the properties of your geometric objects, like color or size. You already know how to do this with ggplot2 plots: add additional mappings to the aesthetics of the geom.

Let's see what else you can learn about these houses in Corvallis.

NOTE: Many exercises in this course will require you to create more than one plot. You can toggle between plots with the arrows at the bottom of the 'Plots' window and zoom in on a plot by clicking the arrows on the tab at the top of the 'Plots' window.

Instructions 3/3
34 XP
Map the color of the points to year_built. How has Corvallis developed as a town?

Map the size of the points to bedrooms. Are there areas of houses with fewer or more bedrooms?

Map the color of the points to price per squarefoot (i.e. price / finished_squarefeet). Are there areas with better "value" than others? What makes this plot unsuccessful?

```{r itta}
# Map color to year_built
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, color = year_built), data = sales)
# Map size to bedrooms
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, size = bedrooms), data = sales)
# Map color to price / finished_squarefeet
ggmap(corvallis_map) +
    geom_point(aes(lon, lat, color = price / finished_squarefeet), data = sales)
```

Different maps
The default Google map downloaded by get_map() is useful when you need major roads, basic terrain, and places of interest, but visually it can be a little busy. You want your map to add to your data, not distract from it, so it can be useful to have other "quieter" options.

Sometimes you aren't really interested in the roads and places, but more what's on the ground (e.g. grass, trees, desert, or snow), in which case switching to a satellite view might be more useful. You can get Google satellite images by changing the maptype argument to "satellite".

You can grab Stamen Maps by using source = "stamen" in get_map(), along with specifying a maptype argument. You can see all possible values for the maptype argument by looking at ?get_map, but they correspond closely to the "flavors" described on the Stamen Maps site. I like the "toner" variations, as they are greyscale and a bit simpler than the Google map.

Let's try some other maps for your plot of house sales.

Instructions 2/2
50 XP
Edit your original call to get_map() to get a "satellite" image from Google by adding a maptype argument.
Display a plot of house sales coloured by year_built using the satellite map.
Edit your original call to get_map() to get a toner map from Stamen by adding a source argument and a maptype argument.
Display a plot of house sales coloured by year_built using the toner map.

```{r dm}
corvallis <- c(lon = -123.2620, lat = 44.5646)

# Add a maptype argument to get a satellite map
corvallis_map_sat <- get_map(corvallis, zoom = 13, maptype = "satellite")
 
 
# Edit to display satellite map
ggmap(corvallis_map_sat) +
  geom_point(aes(lon, lat, color = year_built), data = sales)

corvallis <- c(lon = -123.2620, lat = 44.5646)
 
# Add source and maptype to get toner map from Stamen Maps
corvallis_map_bw <- get_map(corvallis, zoom = 13, source = "stamen", maptype = "toner")

# Edit to display toner map
ggmap(corvallis_map_bw) +
  geom_point(aes(lon, lat, color = year_built), data = sales)
```

Leveraging ggplot2's strengths
You've seen you can add layers to a ggmap() plot by adding geom_***() layers and specifying the data and mapping explicitly, but this approach has two big downsides: further layers also need to specify the data and mappings, and facetting won't work at all.

Luckily ggmap() provides a way around these downsides: the base_layer argument. You can pass base_layer a normal ggplot() call that specifies the default data and mappings for all layers.

For example, the initial plot:

ggmap(corvallis_map) +
  geom_point(data = sales, aes(lon, lat))
could have instead been:

ggmap(corvallis_map, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point()
By moving aes(x, y) and data from the initial geom_point() function to the ggplot() call within the ggmap() call, you can add facets, or extra layers, the usual ggplot2 way.

Let's try it out.

Instructions 1/2
50 XP
1
2
Rewrite the first plot to use the base_layer argument of ggmap().

Add a base_layer argument to the ggmap() call.
This should call ggplot().
Move the data and x and y mappings out of geom_point(). Leave the color argument inside the aes() function within your geom_point() call.

Rewrite the plot to use the base_layer argument of ggmap(). Set the color argument inside the aes() function to class.
Add a facet_wrap() to facet by class. This function takes a formula.

```{r lgs}
# Use base_layer argument to ggmap() to specify data and x, y mappings

  ggmap(corvallis_map_bw, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point(aes(color = year_built))

# Use base_layer argument to ggmap() and add facet_wrap()
  ggmap(corvallis_map_bw, 
    base_layer = ggplot(sales, aes(lon, lat))) +
  geom_point(aes(color = class)) +
  facet_wrap(vars(class))
```

A quick alternative
ggmap also provides a quick alternative to ggmap(). Like qplot() in ggplot2, qmplot() is less flexible than a full specification, but often involves significantly less typing. qmplot() replaces both steps -- downloading the map and displaying the map -- and its syntax is a blend between qplot(), get_map(), and ggmap().

Let's take a look at the qmplot() version of the faceted plot from the previous exercise:

qmplot(lon, lat, data = sales, 
       geom = "point", color = class) +
  facet_wrap(~ class)
Notice we didn't specify a map, since qmplot() will grab one on its own. Otherwise the qmplot() call looks a lot like the corresponding qplot() call: use points to display the sales data, mapping lon to the x-axis, lat to the y-axis, and class to color. qmplot() also sets the default dataset and mapping (without the need for base_layer) so you can add facets without any extra work.

Instructions
100 XP
Using the example as a guide, use qmplot() to create a plot of the house sales where color is mapped to bedrooms, faceted by month.

```{r aqa}
# Plot house sales using qmplot()
qmplot(lon, lat, data = sales, 
       geom = "point", color = bedrooms) +
  facet_wrap(~ month)
```

Drawing polygons
A choropleth map describes a map where polygons are colored according to some variable. In the ward_sales data frame, you have information on the house sales summarised to the ward level. Your goal is to create a map where each ward is colored by one of your summaries: the number of sales or the average sales price.

In the data frame, each row describes one point on the boundary of a ward. The lon and lat variables describe its location and ward describes which ward it belongs to, but what are group and order?

Remember the two tricky things about polygons? An area may be described by more than one polygon and order matters. group is an identifier for a single polygon, but a ward may be composed of more than one polygon, so you would see more than one value of group for such a ward. order describes the order in which the points should be drawn to create the correct shapes.

In ggplot2, polygons are drawn with geom_polygon(). Each row of your data is one point on the boundary and points are joined up in the order in which they appear in the data frame. You specify which variables describe position using the x and y aesthetics and which points belong to a single polygon using the group aesthetic.

This is a little tricky, so before you make your desired plot, let's explore this a little more.

Instructions 4/4
25 XP
The ward_sales data frame is loaded in your workspace. You may want to take a look with head(ward_sales).

Add a geom_point() layer with the color aesthetic mapped to ward. How many wards are in Corvallis?
Add a geom_point() layer with the color aesthetic mapped to group. Can you see some wards that are described by more than one polygon?
Add a geom_path() layer with the group aesthetic mapped to group. See how points in the same group are joined.
Finally, add a geom_polygon() layer with the fill aesthetic mapped to ward and the group aesthetic mapped to group.

```{r dp}
ward_sales <- read.csv("ward_sales.csv")

# Add a point layer with color mapped to ward
ggplot(ward_sales, aes(lon, lat)) +
geom_point(aes(color = ward))

# Add a point layer with color mapped to group

ggplot(ward_sales, aes(lon, lat)) +
geom_point(aes(color = group))

# Add a path layer with group mapped to group
ggplot(ward_sales, aes(lon, lat)) +
geom_path(aes(group = group))

# Add a polygon layer with fill mapped to ward, and group to group
ggplot(ward_sales, aes(lon, lat)) +
geom_polygon(aes(fill = as.factor(ward), group = group))
```

Choropleth map
Now that you understand drawing polygons, let's get your polygons on a map. Remember, you replace your ggplot() call with a ggmap() call and the original ggplot() call moves to the base_layer() argument, then you add your polygon layer as usual:

ggmap(corvallis_map_bw,
      base_layer = ggplot(ward_sales,
                          aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = ward))
Try it out in the console now!

Uh oh, things don't look right. Wards 1, 3 and 8 look jaggardy and wrong. What's happened? Part of the ward boundaries are beyond the map boundary. Due to the default settings in ggmap(), any data off the map is dropped before plotting, so some polygon boundaries are dropped and when the remaining points are joined up you get the wrong shapes.

Don't worry, there is a solution: ggmap() provides some arguments to control this behaviour. Arguments extent = "normal" along with maprange = FALSE force the plot to use the data range rather than the map range to define the plotting boundaries.

Instructions 3/3
30 XP
Update the ggmap() call to fix the polygon cropping.
Set extent to "normal" and maprange to FALSE.
Update the plot, swapping the polygon fill color from ward to num_sales.
Update the plot again, mapping fill to avg_price. Also, set alpha to 0.8 in your call to geom_polygon() to allow the map to show through.

```{r cm}
# Fix the polygon cropping
ggmap(corvallis_map_bw, 
      base_layer = ggplot(ward_sales, aes(lon, lat)), extent = "normal", maprange = FALSE) +
  geom_polygon(aes(group = group, fill = ward))

# Repeat, but map fill to num_sales
ggmap(corvallis_map_bw, 
      base_layer = ggplot(ward_sales, aes(lon, lat)),
      extent = "normal", maprange = FALSE) +
  geom_polygon(aes(group = group, fill = num_sales))

# Repeat again, but map fill to avg_price
ggmap(corvallis_map_bw, 
      base_layer = ggplot(ward_sales, aes(lon, lat)),
      extent = "normal", maprange = FALSE) +
  geom_polygon(aes(group = group, fill = avg_price), alpha = .8)
```

Raster data as a heatmap
The predicted house prices in preds are called raster data: you have a variable measured (or in this case predicted) at every location in a regular grid.

Looking at head(preds) in the console, you can see the lat values stepping up in intervals of about 0.002, as lon is constant. After 40 rows, lon increases by about 0.003, as lat runs through the same values. For each lat/lon location, you also have a predicted_price. You'll see later in Chapter 3, that a more useful way to think about (and store) this kind of data is in a matrix.

When data forms a regular grid, one approach to displaying it is as a heatmap. geom_tile() in ggplot2 draws a rectangle that is centered on each location that fills the space between it and the next location, in effect tiling the whole space. By mapping a variable to the fill aesthetic, you end up with a heatmap.

Instructions 3/3
0 XP
Create a simple dot plot of the locations in preds by adding a geom_point() layer to the first ggplot() call. Verify that the locations form a regular grid.
To the second ggplot(), swap geom_point() for geom_tile(), where predicted_price is mapped to fill. Remember that fill is an argument to aes(), which is the first and only argument in your call to geom_tile().
Create a ggmap() using the corvallis_map_bw map.
Add a geom_tile() layer with lon, lat, and predicted_price aesthetics from the second plot.
Use preds as the layer's data.
Set the layer's alpha transparency to 0.8.

```{r rdhm}
preds <- read.csv("preds.csv")

# Add a geom_point() layer
ggplot(preds, aes(lon, lat)) + geom_point()

# Add a tile layer with fill mapped to predicted_price
ggplot(preds, aes(lon, lat)) + geom_tile(aes(fill=predicted_price))

# Use ggmap() instead of ggplot()
ggmap(corvallis_map_bw) +
  geom_tile(aes(lon, lat, fill = predicted_price), 
            data = preds, alpha = 0.8)
```

## Points and Polygons

Let's take a look at a spatial object
We've loaded a particular sp object into your workspace: countries_sp. There are special print(), summary() and plot() methods for these objects. What's a method? It's a special version of a function that gets used based on the type of object you pass to it. It's common when a package creates new types of objects for it to contain methods for simple exploration and display.

In practice, this means you can call plot(countries_sp) and if there is a method for the class of countries_sp, it gets called. The print() method is the one called when you just type an object's name in the console.

Can you figure out what kind of object this countries_sp is? Can you see what coordinate system this spatial data uses? What does the data in the object describe?

Instructions
100 XP
Print countries_sp. Why isn't this very useful?.
Call summary() on countries_sp.
Call plot() on countries_sp.

```{r splook}
load(file = "countries_sp.rda")

# Print countries_sp
print(countries_sp)

# Call summary() on countries_sp
summary(countries_sp)

# Call plot() on countries_sp
plot(countries_sp)
```

What's inside a spatial object?
What did you learn about the methods in the previous exercise? print() gives a printed form of the object, but it is often too long and not very helpful. summary() provides a much more concise description of the object, including its class (in this case SpatialPolygons), the extent of the spatial data, and the coordinate reference system information (you'll learn more about this in Chapter 4). plot() displays the contents, in this case drawing a map of the world.

But, how is that information stored in the SpatialPolygons object? In this exercise you'll explore the structure of this object. You already know about using str() to look at R objects, but what you might not know is that it takes an optional argument max.level that restricts how far down the hierarchy of the object str() prints. This can be useful to limit how much information you have to handle.

Let's see if you can get a handle on how this object is structured.

Instructions
100 XP
Call str() on countries_sp. This won't be very helpful, except to convince you this is a complicated stucture!
Call str() on countries_sp, setting max.level to 2. What is at the highest level of this object? Can you see where things might be stored?

```{r wiiso}
# Call str() on countries_sp
str(countries_sp)

# Call str() on countries_sp with max.level = 2
str(countries_sp, max.level = 2)
```

A more complicated spatial object
You probably noticed something a little different about the structure of countries_sp. It looked a lot like a list, but instead of the elements being proceeded by $ in the output they were instead proceeded by an @. This is because the sp classes are S4 objects, so instead of having elements they have slots and you access them with @. You'll learn more about this in the next video.

Right now, let's take a look at another object countries_spdf. It's a little more complicated than countries_sp, but you are now well-equipped to figure out how this object differs.

Take a look!

Instructions
100 XP
Call summary() on countries_sp and then on this new object countries_spdf (one at a time). What kind of object is this? What differs between this and countries_sp?
Call str() with max.level = 2 on countries_spdf. How does the structure differ from countries_sp?
Call plot() on countries_spdf.

```{r mcso}
load(file = "countries_spdf.rda")

# Call summary() on countries_spdf and countries_sp
summary(countries_spdf)
summary(countries_sp)


# Call str() with max.level = 2 on countries_spdf
str(countries_spdf, max.level = 2)

# Plot countries_spdf
plot(countries_spdf)
```

Walking the hierarchy
Let's practice accessing slots by exploring the way polygons are stored inside SpatialDataFrame objects. Remember there are two ways to access slots in an S4 object:

x@slot_name # or...
slot(x, "slot_name")
So, to take a look at the polygons slot of countries_spdf you simply do countries_spdf@polygons. You can try it, but you'll get a long and not very informative output. Let's look at the high level structure instead.

Try running the following code in the console:

str(countries_spdf@polygons, max.level = 2)
Still a pretty long output, but scroll back to the top and take a look. What kind of object is this? It's just a list, but inside its elements are another kind of sp class: Polygons. There are 177 list elements. Any guesses what they might represent?

Let's dig into one of these elements.

Instructions
100 XP
Create a new variable called one that contains the 169th element of the list in the polygons slot of countries_spdf. Use double bracket subsetting (i.e. [[...]] to extract this element.
Print one.
Call summary() on one. What slots does this object have?
Call str() on one with max.level = 2.

```{r wth}
# 169th element of countries_spdf@polygons: one
one <- countries_spdf@polygons[[169]]

# Print one
print(one)

# Call summary() on one
summary(one)

# Call str() on one with max.level = 2
str(one, max.level = 2)
```

Further down the rabbit hole
In the last exercise, the SpatialPolygonsDataFrame had a list of Polygons in its polygons slot, and each of those Polygons objects also had a Polygons slot. So, many polygons...but you aren't at the bottom of the hierarchy yet!

Let's take another look at the 169th element in the Polygons slot of countries_spdf. Run this code from the previous exercise:

one <- countries_spdf@polygons[[169]]
str(one, max.level = 2)
The Polygons slot has a list inside with 10 elements. What are these objects? Let's keep digging....

Instructions
100 XP
Call str() with max.level = 2 on the Polygons slot of one.
Call str() with max.level = 2 on the 6th element of the Polygons slot of one. Do you see something that looks like it might be spatial data?
Call plot() on the coords slot of the 6th element of the Polygons slot of one. Do you recognise what data this object contains?

```{r fdrh}
one <- countries_spdf@polygons[[169]]

# str() with max.level = 2, on the Polygons slot of one
str(one@Polygons, max.level = 2)

# str() with max.level = 2, on the 6th element of the one@Polygons
str(one@Polygons[[6]], max.level = 2)

# Call plot on the coords slot of 6th element of one@Polygons
plot(one@Polygons[[6]]@coords)
```

Subsetting by index
The subsetting of Spatial___DataFrame objects is built to work like subsetting a data frame. You think about subsetting the data frame, but in practice what is returned is a new Spatial___DataFrame with only the rows of data you want and the corresponding spatial objects.

The simplest kind of subsetting is by index. For example, if x is a data frame you know x[1, ] returns the first row. If x is a Spatial___DataFrame, you get a new Spatial___DataFrame that contains the first row of data and the spatial data that correspond to that row.

The benefit of returning a Spatial___DataFrame is you can use all the same methods as on the object before subsetting.

Let's test it out on the 169th country!

Instructions
100 XP
Create a new variable usa by subsetting the 169th element of countries_spdf.
Call summary() on usa. Verify usa is still a SpatialPolygonsDataFrame.
Call str() with max.level = 2 on usa. Verify there is only one element of the polygons slot and only one row in the data slot.
Call plot() on usa.

```{r sbi}
# Subset the 169th object of countries_spdf: usa
usa <- countries_spdf[169,]

# Look at summary() of usa
summary(usa)

# Look at str() of usa
str(usa, max.level = 2)

# Call plot() on usa
plot(usa)
```

Accessing data in sp objects
It's quite unusual to know exactly the indices of elements you want to keep, and far more likely you want to subset based on data attributes. You've seen the data associated with a Spatial___DataFrame lives in the data slot, but you don't normally access this slot directly.

Instead,$ and [[ subsetting on a Spatial___DataFrame pulls columns directly from the data frame. That is, if x is a Spatial___DataFrame object, then either x$col_name or x[["col_name"]] pulls out the col_name column from the data frame. Think of this like a shortcut; instead of having to pull the right column from the object in the data slot (i.e. x@data$col_name), you can just use x$col_name.

Let's start by confirming the object in the data slot is just a regular data frame, then practice pulling out columns.

Instructions
100 XP
Call head() and str() (one at a time) on the data slot of countries_spdf. Verify that this object is just a regular data frame.
Pull out the name column of countries_spdf using $.
Pull out the subregion column of countries_spdf using [[.

```{r adso}
# Call head() and str() on the data slot of countries_spdf
head(countries_spdf@data)
str(countries_spdf@data)

# Pull out the name column using $
countries_spdf$name

# Pull out the subregion column using [[
countries_spdf[["subregion"]]
```

Subsetting based on data attributes
Subsetting based on data attributes is a combination of creating a logical from the columns of your data frame and subsetting the Spatial___DataFrame object. This is similar to how you subset an ordinary data frame.

Create a logical from a column, let's say countries in Asia:

in_asia <- countries_spdf$region == "Asia"
in_asia
Then, use the logical to select rows of the Spatial___DataFrame object:

countries_spdf[in_asia, ]
Can you subset out New Zealand and plot it?

Instructions
100 XP
Create a logical vector called is_nz that tests if the name column is equal to "New Zealand".
Create a new spatial object called nz by using is_nz to subset countries_spdf.
Plot nz.

```{r sbda}
# Create logical vector: is_nz
is_nz <- countries_spdf$name == "New Zealand"

# Subset countries_spdf using is_nz: nz
nz <- countries_spdf[is_nz,]

# Plot nz
plot(nz)
```

tmap, a package that works with sp objects
You've had to learn quite a few new things just to be able to understand and do basic manipulation of these spatial objects defined by sp, but now you get to experience some payoff! There are a number of neat packages that expect spatial data in sp objects and which make working with spatial data easy.

Let's take a look at the tmap package for creating maps. You'll learn more about its philosophy and structure in the next video, but first we want you to see how easy it is to use.

tmap has the qtm() function for quick thematic maps. It follows the ideas of qplot() from ggplot2 but with a couple of important differences. Instead of expecting data in a data frame like ggplot2(), it expects data in a spatial object and uses the argument shp to specify it. Another important difference is that tmap doesn't use non-standard evaluation (see the Writing Functions in R course for more about this), so variables need to be surrounded by quotes when specifying mappings.

Try this example in the console:

library(tmap)
qtm(shp = countries_spdf, fill = "population")
How easy was that!? Can you make a choropleth of another variable contained in countries_spdf: gdp?

Instructions
100 XP
Using the example as a guide, create a choropleth map of the gdp variable using qtm().

```{r tmap}
library(sp)
library(tmap)

# Use qtm() to create a choropleth map of gdp
qtm(shp = countries_spdf, fill = "gdp")
```

Building a plot in layers
Now that you know a bit more about tmap(), let's build up your previous plot of population in layers and make a few tweaks to improve it. You start with a tm_shape() layer that defines the data you want to use, then add a tm_fill() layer to color-in your polygons using the variable population:

tm_shape(countries_spdf) +
  tm_fill(col = "population") 
Probably the biggest problem with the resulting plot is that the color scale isn't very informative: the first color (palest yellow) covers all countries with population less than 200 million! Since the color scale is associated with the tm_fill() layer, tweaks to this scale happen in this call. You'll learn a lot more about color in Chapter 3, but for now, know that the style argument controls how the breaks are chosen.

Your plot also needs some country outlines. You can add a tm_borders() layer for this, but let's not make them too visually strong. Perhaps a brown would be nice.

The benefit of using spatial objects becomes really clear when you switch the kind of plot you make. Let's also try a bubble plot where the size of the bubbles correspond to population. If you were using ggplot2, this would involve a lot of reshaping of your data. With tmap, you just switch out a layer.

Instructions
100 XP
Add style = "quantile" to tm_fill(). This chooses the breaks in the color scale based on equal numbers of observations in each interval.
To the same plot, add a tm_borders() layer with col = "burlywood4".
Create new plot the same as the first, but instead of tm_fill() add a tm_bubbles() layer with size mapped to population.

```{r bpil}
library(sp)
library(tmap)

# Add style argument to the tm_fill() call
tm_shape(countries_spdf) +
  tm_fill(col = "population", style = "quantile") +
  # Add a tm_borders() layer 
  tm_borders(col = "burlywood4")

# New plot, with tm_bubbles() instead of tm_fill()
tm_shape(countries_spdf) +
  tm_bubbles(size = "population", style = "quantile") +
  # Add a tm_borders() layer 
  tm_borders(col = "burlywood4")
```

Why is Greenland so big?
Take a closer look at the plot. Why does Greenland look bigger than the contiguous US when it's actually only about one-third the size?

When you plot longitude and latitude locations on the x- and y-axes of a plot, you are treating 1 degree of longitude as the same size no matter where you are. However, because the earth is roughly spherical, the distance described by 1 degree of longitude depends on your latitude, varying from 111km at the equator, to 0 km at the poles.

The way you have taken positions on a sphere and drawn them in a two dimensional plane is described by a projection. The default you've used here (also known as an Equirectangular projection) distorts the width of areas near the poles. Every projection involves some kind of distortion (since a sphere isn't a plane!), but different projections try to preserve different properties (e.g. areas, angles or distances).

In tmap, tm_shape() takes an argument projection that allows you to swap projections for the plot.

(Note: changing the projection of a ggplot2 plot is done using the coord_map() function. See ?coord_map() for more details.)

Instructions
100 XP
To help you see the differences between projections, we've added a tm_grid() layer which adds equispaced longitude and latitude lines to the plot.

Within your tm_shape() call:

Try a Hobo–Dyer projection (projection = "hd"), designed to preserve area.
In a second plot, try a Robinson projection (projection = "robin"), designed as a compromise between preserving local angles and area.
Just for fun, repeat the previous plot, but add tm_style_classic() to see how tmap can control all aspects of the maps display.

```{r wigsb}
library(sp)
library(tmap)

# Switch to a Hobo–Dyer projection
tm_shape(countries_spdf, projection = "hd") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Switch to a Robinson projection
tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Add tm_style_classic() to your plot
tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") +
  tm_style("classic")
```

Saving a tmap plot
Saving tmap plots is easy with the tmap_save() function. The first argument, tm, is the plot to save and the second, filename, is the file to save it to. If you leave tm unspecified, the last tmap plot printed will be saved.

The extension of the file name specifies the file type, for example .png or .pdf for static plots. One really neat thing about tmap is that you can save an interactive version which leverages the leaflet package. To get an interactive version, use tmap_save() but use the file name extension .html.

Instructions
100 XP
Save your plot from the previous exercise in the following ways. Neither plot will display in your workspace, but you'll be able to take a look at them once you complete the exercise.

Save it as a static plot by specifying the filename population.png.
Save it as an interactice plot by specifying the filename population.html.

```{r satp}
library(sp)
library(tmap)

# Plot from last exercise
tm_shape(countries_spdf) +
  tm_grid(n.x = 11, n.y = 11, projection = "longlat") +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4")

# Save a static version "population.png"
tmap_save(filename = "population.png")

# Save an interactive version "population.html"
tm_shape(countries_spdf) +
  tm_grid(n.x = 11, n.y = 11, projection = "longlat") +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4")

tmap_save(filename = "population.html")
```

## Raster

What's a raster object?
Just like sp classes, the raster classes have methods to help with basic viewing and manipulation of objects, like print() and summary(), and you can always dig deeper into their structure with str().

Let's jump in and take a look at a raster we've loaded for you, pop. Keep an eye out for a few things:

Can you see where the coordinate information is kept?
Can you tell from the summary() how big the raster is?
What do you think might be stored in this raster?
Instructions
100 XP
Print pop to the console.
Call str() on pop with max.level = 2.
Call summary() on pop.

```{r wiaro}
load(file = "pop.rda")

library(raster)

# Print pop
print(pop)

# Call str() on pop, with max.level = 2
str(pop, max.level = 2)

# Call summary on pop
summary(pop)
```

Some useful methods
pop is a RasterLayer object, which contains the population around the Boston and NYC areas. Each grid cell simply contains a count of the number of people that live inside that cell.

You saw in the previous exercise that print() gives a useful summary of the object including the coordinate reference system, the size of the grid (both in number of rows and columns and geographical coordinates), and some basic info on the values stored in the grid. But it was very succinct; what if you want to see some of the values in the object?

The first way is to simply plot() the object. There is a plot() method for raster objects that creates a heatmap of the values.

If you want to extract the values from a raster object you can use the values() function, which pulls out a vector of the values. There are 316,800 values in the pop raster, so you won't want to print them all out, but you can use str() and head() to take a peek.

Instructions
100 XP
Call plot() on pop. Can you see where NYC is?
Call str() on values(pop).
Call head() on values(pop).

```{r sum}
# Call plot() on pop
plot(pop)

# Call str() on values(pop)
str(values(pop))

# Call head() on values(pop)
head(values(pop))
```

A more complicated object
The raster package provides the RasterLayer object, but also a couple of more complicated objects: RasterStack and RasterBrick. These two objects are designed for storing many rasters, all of the same extents and dimension (a.k.a. multi-band, or multi-layer rasters).

You can think of RasterLayer like a matrix, but RasterStack and RasterBrick objects are more like three dimensional arrays. One additional thing you need to know to handle them is how to specify a particular layer.

You can use $ or [[ subsetting on a RasterStack or RasterBrick to grab one layer and return a new RasterLayer object. For example, if x is a RasterStack, x$layer_name or x[["layer_name"]] will return a RasterLayer with only the layer called layer_name in it.

Let's look at a RasterStack object called pop_by_age that covers the same area as pop but now contains layers for population broken into few different age groups.

Instructions
100 XP
Print pop_by_age. Can you see the names of all the layers?
Subset out the under_1 layer using [[ subsetting.
Plot the under_1 layer by passing your code from the previous instruction to plot().

```{r amco}
load(file = "pop_by_age.rda")

# Print pop_by_age
pop_by_age

# Subset out the under_1 layer using [[
pop_by_age[["under_1"]]

# Plot the under_1 layer
plot(pop_by_age[["under_1"]])
```

A package that uses Raster objects
You saw the tmap package makes visualizing spatial classes in sp easy. The good news is that it works with the raster classes too! You simply pass your Raster___ object as the shp argument to the tm_shape() function, and then add a tm_raster() layer like this:

tm_shape(raster_object) +
    tm_raster()
When working with a RasterStack or a RasterBrick object, such as the pop_by_age object you created in the last exercise, you can display one of its layers using the col (short for "color") argument in tm_raster(), surrounding the layer name in quotes.

You'll work with tmap throughout the course, but we also want to show you another package, rasterVis, also designed specifically for visualizing raster objects. There are a few different functions you can use in rasterVis to make plots, but let's just try one of them for now: levelplot().

Instructions
100 XP
Use tmap to plot the pop object, by specifying pop as the shp argument to tm_shape() and adding a tm_raster() layer.
Use tmap to plot the under_1 layer of pop_by_age, a RasterStack object.
Call the rasterVis function levelplot() on pop.

```{r apturo}
library(tmap)

# Specify pop as the shp and add a tm_raster() layer
tm_shape(pop) +
  tm_raster()

# Plot the under_1 layer in pop_by_age
tm_shape(pop_by_age) +
  tm_raster(col = "under_1")

library(rasterVis)
# Call levelplot() on pop
levelplot(pop)
```

Adding a custom continuous color palette to ggplot2 plots
The most versatile way to add a custom continuous scale to ggplot2 plots is with scale_color_gradientn() or scale_fill_gradientn(). How do you know which to use? Match the function to the aesthetic you have mapped. For example, in your plot of predicted house price from Chapter 1, you mapped fill to price, so you'd need to use scale_fill_gradientn().

These two functions take an argument colors where you pass a vector of colors that defines your palette. This is where the versatility comes in. You can generate your palette in any way you choose, automatically using something like RColorBrewer or viridisLite, or manually by specifying colors by name or hex code.

The scale___gradientn() functions handle how these colors are mapped to values of your variable, although there is control available through the values argument.

Let's play with some alternative color scales for your predicted house price heatmap from Chapter 1 (we've dropped the map background to reduce computation time, so you can see your plots quickly).

Instructions 3/3
0 XP
Create a palette called blups from 9 steps on the RColorBrewer palette "BuPu".
Add scale_fill_gradientn() and pass the blups palette as the colors argument.
Create a palette called vir from 9 steps on the viridis() palette from viridisLite.
Add scale_fill_gradientn() and pass the vir palette as the colors argument.
Create a palette called mag from 9 steps on the magma() palette from viridisLite.
Add scale_fill_gradientn() and pass the mag palette as the colors argument.

```{r accc}
library(RColorBrewer)
# 9 steps on the RColorBrewer "BuPu" palette: blups
blups <- brewer.pal(9, "BuPu")

# Add scale_fill_gradientn() with the blups palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = blups)

library(viridisLite)
# viridisLite viridis palette with 9 steps: vir
vir <- viridis(9)

# Add scale_fill_gradientn() with the vir palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = vir)

library(viridisLite)
# mag: a viridisLite magma palette with 9 steps
mag <- magma(9)

# Add scale_fill_gradientn() with the mag palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = mag) 
```

Adding a custom continuous color palette to ggplot2 plots
The most versatile way to add a custom continuous scale to ggplot2 plots is with scale_color_gradientn() or scale_fill_gradientn(). How do you know which to use? Match the function to the aesthetic you have mapped. For example, in your plot of predicted house price from Chapter 1, you mapped fill to price, so you'd need to use scale_fill_gradientn().

These two functions take an argument colors where you pass a vector of colors that defines your palette. This is where the versatility comes in. You can generate your palette in any way you choose, automatically using something like RColorBrewer or viridisLite, or manually by specifying colors by name or hex code.

The scale___gradientn() functions handle how these colors are mapped to values of your variable, although there is control available through the values argument.

Let's play with some alternative color scales for your predicted house price heatmap from Chapter 1 (we've dropped the map background to reduce computation time, so you can see your plots quickly).

Instructions 3/3
0 XP
Create a palette called blups from 9 steps on the RColorBrewer palette "BuPu".
Add scale_fill_gradientn() and pass the blups palette as the colors argument.
Create a palette called vir from 9 steps on the viridis() palette from viridisLite.
Add scale_fill_gradientn() and pass the vir palette as the colors argument.
Create a palette called mag from 9 steps on the magma() palette from viridisLite.
Add scale_fill_gradientn() and pass the mag palette as the colors argument.

```{r accc}
library(RColorBrewer)
# 9 steps on the RColorBrewer "BuPu" palette: blups
blups <- brewer.pal(9, "BuPu")

# Add scale_fill_gradientn() with the blups palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = blups)

library(viridisLite)
# viridisLite viridis palette with 9 steps: vir
vir <- viridis(9)

# Add scale_fill_gradientn() with the vir palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = vir)

library(viridisLite)
# mag: a viridisLite magma palette with 9 steps
mag <- magma(9)

# Add scale_fill_gradientn() with the mag palette
ggplot(preds) +
  geom_tile(aes(lon, lat, fill = predicted_price), alpha = 0.8) +
  scale_fill_gradientn(colors = mag) 
```

Custom palette in tmap
Unlike ggplot2, where setting a custom color scale happens in a scale_ call, colors in tmap layers are specified in the layer in which they are mapped. For example, take a plot of the age_18_24 variable from prop_by_age:

tm_shape(prop_by_age) +
  tm_raster(col = "age_18_24") 
Since color is mapped in the tm_raster() call, the specification of the palette also occurs in this call. You simply specify a vector of colors in the palette argument. This is a another reason it's worth learning ways to generate a vector of colors. While different packages could have very different shortcuts for specifying palettes from color packages, they will generally always have a way to pass in a vector of colors.

Let's use some palettes from the last exercise with this plot.

Instructions
100 XP
In the first plot, use the blups palette instead of the default.
In the second plot, use the vir palette instead of the default.
In the third plot, use the rev(mag) palette instead of the default. rev() just reverses the order of a vector, so this uses the same colors but in the opposite order.

```{r cpot}
load(file = "prop_by_age.rda")

# Generate palettes from last time
library(RColorBrewer)
blups <- brewer.pal(9, "BuPu")

library(viridisLite)
vir <- viridis(9)
mag <- magma(9)

# Use the blups palette
tm_shape(prop_by_age) +
  tm_raster("age_18_24", palette = blups) +
  tm_legend(position = c("right", "bottom"))

# Use the vir palette
tm_shape(prop_by_age) +
  tm_raster("age_18_24", palette = vir) +
  tm_legend(position = c("right", "bottom"))

# Use the mag palette but reverse the order
tm_shape(prop_by_age) +
  tm_raster("age_18_24", palette = rev(mag)) +
  tm_legend(position = c("right", "bottom"))
```




